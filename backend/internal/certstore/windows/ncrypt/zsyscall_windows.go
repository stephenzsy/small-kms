// Code generated by 'go generate'; DO NOT EDIT.

package ncrypt

import (
	"syscall"
	"unsafe"

	"golang.org/x/sys/windows"
)

var _ unsafe.Pointer

// Do the interface allocations only once for common
// Errno values.
const (
	errnoERROR_IO_PENDING = 997
)

var (
	errERROR_IO_PENDING error = syscall.Errno(errnoERROR_IO_PENDING)
	errERROR_EINVAL     error = syscall.EINVAL
)

// errnoErr returns common boxed Errno values, to prevent
// allocations at runtime.
func errnoErr(e syscall.Errno) error {
	switch e {
	case 0:
		return errERROR_EINVAL
	case errnoERROR_IO_PENDING:
		return errERROR_IO_PENDING
	}
	// TODO: add more here, after collecting data on the common
	// error values see on Windows. (perhaps when running
	// all.bat?)
	return e
}

var (
	modncrypt = windows.NewLazySystemDLL("ncrypt.dll")

	procNCryptCreatePersistedKey  = modncrypt.NewProc("NCryptCreatePersistedKey")
	procNCryptDeleteKey           = modncrypt.NewProc("NCryptDeleteKey")
	procNCryptExportKey           = modncrypt.NewProc("NCryptExportKey")
	procNCryptFinalizeKey         = modncrypt.NewProc("NCryptFinalizeKey")
	procNCryptFreeObject          = modncrypt.NewProc("NCryptFreeObject")
	procNCryptOpenKey             = modncrypt.NewProc("NCryptOpenKey")
	procNCryptOpenStorageProvider = modncrypt.NewProc("NCryptOpenStorageProvider")
	procNCryptSetProperty         = modncrypt.NewProc("NCryptSetProperty")
	procNCryptSignHash            = modncrypt.NewProc("NCryptSignHash")
)

func CreatePersistedKey(hProvider PROV_HANDLE, phKey *KEY_HANDLE, pszAlgId *uint16, pszKeyName *uint16, dwLegacyKeySpec uint32, dwFlags uint32) (s error) {
	r0, _, _ := syscall.Syscall6(procNCryptCreatePersistedKey.Addr(), 6, uintptr(hProvider), uintptr(unsafe.Pointer(phKey)), uintptr(unsafe.Pointer(pszAlgId)), uintptr(unsafe.Pointer(pszKeyName)), uintptr(dwLegacyKeySpec), uintptr(dwFlags))
	if r0 != 0 {
		s = syscall.Errno(r0)
	}
	return
}

func DeleteKey(hKey KEY_HANDLE, dwFlags uint32) (s error) {
	r0, _, _ := syscall.Syscall(procNCryptDeleteKey.Addr(), 2, uintptr(hKey), uintptr(dwFlags), 0)
	if r0 != 0 {
		s = syscall.Errno(r0)
	}
	return
}

func ExportKey(hKey KEY_HANDLE, hExportKey KEY_HANDLE, pszBlobType *uint16, pParameterList *BufferDesc, pbOutput []byte, pcbResult *uint32, dwFlags uint32) (s error) {
	var _p0 *byte
	if len(pbOutput) > 0 {
		_p0 = &pbOutput[0]
	}
	r0, _, _ := syscall.Syscall9(procNCryptExportKey.Addr(), 8, uintptr(hKey), uintptr(hExportKey), uintptr(unsafe.Pointer(pszBlobType)), uintptr(unsafe.Pointer(pParameterList)), uintptr(unsafe.Pointer(_p0)), uintptr(len(pbOutput)), uintptr(unsafe.Pointer(pcbResult)), uintptr(dwFlags), 0)
	if r0 != 0 {
		s = syscall.Errno(r0)
	}
	return
}

func FinalizeKey(hKey KEY_HANDLE, dwFlags uint32) (s error) {
	r0, _, _ := syscall.Syscall(procNCryptFinalizeKey.Addr(), 2, uintptr(hKey), uintptr(dwFlags), 0)
	if r0 != 0 {
		s = syscall.Errno(r0)
	}
	return
}

func FreeObject(hObject HANDLE) (s error) {
	r0, _, _ := syscall.Syscall(procNCryptFreeObject.Addr(), 1, uintptr(hObject), 0, 0)
	if r0 != 0 {
		s = syscall.Errno(r0)
	}
	return
}

func OpenKey(hProvider PROV_HANDLE, phKey *KEY_HANDLE, pszKeyName *uint16, dwLegacyKeySpec uint32, dwFlags uint32) (s error) {
	r0, _, _ := syscall.Syscall6(procNCryptOpenKey.Addr(), 5, uintptr(hProvider), uintptr(unsafe.Pointer(phKey)), uintptr(unsafe.Pointer(pszKeyName)), uintptr(dwLegacyKeySpec), uintptr(dwFlags), 0)
	if r0 != 0 {
		s = syscall.Errno(r0)
	}
	return
}

func OpenStorageProvider(phProvider *PROV_HANDLE, pszProviderName *uint16, dwFlags uint32) (s error) {
	r0, _, _ := syscall.Syscall(procNCryptOpenStorageProvider.Addr(), 3, uintptr(unsafe.Pointer(phProvider)), uintptr(unsafe.Pointer(pszProviderName)), uintptr(dwFlags))
	if r0 != 0 {
		s = syscall.Errno(r0)
	}
	return
}

func SetProperty(hObject HANDLE, pszProperty *uint16, pbInput *byte, cbInput uint32, dwFlags uint32) (s error) {
	r0, _, _ := syscall.Syscall6(procNCryptSetProperty.Addr(), 5, uintptr(hObject), uintptr(unsafe.Pointer(pszProperty)), uintptr(unsafe.Pointer(pbInput)), uintptr(cbInput), uintptr(dwFlags), 0)
	if r0 != 0 {
		s = syscall.Errno(r0)
	}
	return
}

func SignHash(hKey KEY_HANDLE, pPaddingInfo unsafe.Pointer, pbHashValue []byte, pbSignature []byte, pcbResult *uint32, dwFlags PadMode) (s error) {
	var _p0 *byte
	if len(pbHashValue) > 0 {
		_p0 = &pbHashValue[0]
	}
	var _p1 *byte
	if len(pbSignature) > 0 {
		_p1 = &pbSignature[0]
	}
	r0, _, _ := syscall.Syscall9(procNCryptSignHash.Addr(), 8, uintptr(hKey), uintptr(pPaddingInfo), uintptr(unsafe.Pointer(_p0)), uintptr(len(pbHashValue)), uintptr(unsafe.Pointer(_p1)), uintptr(len(pbSignature)), uintptr(unsafe.Pointer(pcbResult)), uintptr(dwFlags), 0)
	if r0 != 0 {
		s = syscall.Errno(r0)
	}
	return
}
